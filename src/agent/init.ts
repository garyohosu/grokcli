import * as fs from 'fs/promises';
import * as path from 'path';
import * as os from 'os';

interface InitState {
  agentDir: string;
  goalExists: boolean;
  goalUpdated: boolean;
  meta: {
    goal_timestamp: string;
    last_run: string;
    iterations: number;
  };
}

const AGENT_DIR = path.join(os.homedir(), '.grok_agent');
const TEMPLATES_DIR = path.join(AGENT_DIR, 'templates');

const AUTO_GENERATED_FILES = [
  'planner.md',
  'executor.md',
  'result.md',
  'reviewer.md',
  'final_report.md'
];

/**
 * Default template content
 */
const DEFAULT_TEMPLATES = {
  planner: `# Planner Agent Output Template

You are the Planner Agent.
Your job is to create the next concrete, actionable step toward completing the goal.

## Step Plan
Describe **one clear task** to perform next.

## Reasoning
Explain briefly why this task is the correct next step.

## Expected Output Format
Describe exactly what executor.md should produce after executing this plan.
`,
  executor: `# Executor Agent Output Template

You are the Executor Agent.
Follow the planner's instructions strictly.

## Execution Result
Perform the task described in planner.md.

## Result Data
Write the actual produced output here.
This becomes result.md and will be reviewed.

## Notes
If any information is missing or unclear, state it explicitly.
`,
  reviewer: `# Reviewer Agent Output Template

You are the Reviewer Agent.
Evaluate whether the result.md matches the user's goal and the planner's instructions.

## Evaluation
Write:
- What is correct?
- What is incorrect?
- What is missing?
- What must be improved?

## Decision
Output this mandatory YAML block:

\`\`\`yaml
completion: false
needs_fix: true
\`\`\`

Change the fields as needed:
- \`completion: true\` when goal is fully achieved
- \`needs_fix: true\` when executor must revise the output

## Correction Instructions
If \`needs_fix: true\`, provide **exact instructions** for the Updater Agent to apply.
`
};

/**
 * Ensure directory exists
 */
async function ensureDir(dirPath: string): Promise<void> {
  try {
    await fs.mkdir(dirPath, { recursive: true });
  } catch (error) {
    // Ignore if already exists
  }
}

/**
 * Check if file exists
 */
async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Get file modification timestamp
 */
async function getFileTimestamp(filePath: string): Promise<string> {
  try {
    const stats = await fs.stat(filePath);
    return stats.mtime.toISOString();
  } catch {
    return '';
  }
}

/**
 * Load meta.json
 */
async function loadMeta(): Promise<{
  goal_timestamp: string;
  last_run: string;
  iterations: number;
}> {
  const metaPath = path.join(AGENT_DIR, 'meta.json');

  try {
    const content = await fs.readFile(metaPath, 'utf-8');
    return JSON.parse(content);
  } catch {
    // Return default meta if file doesn't exist
    return {
      goal_timestamp: '',
      last_run: '',
      iterations: 0
    };
  }
}

/**
 * Save meta.json
 */
async function saveMeta(meta: {
  goal_timestamp: string;
  last_run: string;
  iterations: number;
}): Promise<void> {
  const metaPath = path.join(AGENT_DIR, 'meta.json');
  await fs.writeFile(metaPath, JSON.stringify(meta, null, 2), 'utf-8');
}

/**
 * Create default templates if they don't exist
 */
async function ensureTemplates(): Promise<void> {
  await ensureDir(TEMPLATES_DIR);

  const templates = [
    { name: 'planner_template.md', content: DEFAULT_TEMPLATES.planner },
    { name: 'executor_template.md', content: DEFAULT_TEMPLATES.executor },
    { name: 'reviewer_template.md', content: DEFAULT_TEMPLATES.reviewer }
  ];

  for (const template of templates) {
    const templatePath = path.join(TEMPLATES_DIR, template.name);
    const exists = await fileExists(templatePath);

    if (!exists) {
      await fs.writeFile(templatePath, template.content, 'utf-8');
    }
  }
}

/**
 * Delete auto-generated files
 */
async function cleanAutoGeneratedFiles(): Promise<void> {
  for (const filename of AUTO_GENERATED_FILES) {
    const filePath = path.join(AGENT_DIR, filename);
    try {
      await fs.unlink(filePath);
    } catch {
      // Ignore errors for missing files
    }
  }
}

/**
 * Initialize agent environment
 */
export async function initAgentEnvironment(): Promise<InitState> {
  // 1. Ensure agent directory exists
  await ensureDir(AGENT_DIR);

  // 2. Ensure templates exist
  await ensureTemplates();

  // 3. Load existing meta
  const meta = await loadMeta();

  // 4. Check if goal.md exists
  const goalPath = path.join(AGENT_DIR, 'goal.md');
  const goalExists = await fileExists(goalPath);

  if (!goalExists) {
    // No goal - return early
    return {
      agentDir: AGENT_DIR,
      goalExists: false,
      goalUpdated: false,
      meta: {
        goal_timestamp: '',
        last_run: new Date().toISOString(),
        iterations: 0
      }
    };
  }

  // 5. Get current goal timestamp
  const currentGoalTimestamp = await getFileTimestamp(goalPath);

  // 6. Check if goal was updated
  const goalUpdated = currentGoalTimestamp !== meta.goal_timestamp;

  if (goalUpdated) {
    // Goal is new or updated - clean auto-generated files
    await cleanAutoGeneratedFiles();

    // Reset iterations
    meta.iterations = 0;
    meta.goal_timestamp = currentGoalTimestamp;
  }

  // 7. Update last_run timestamp
  meta.last_run = new Date().toISOString();

  // 8. Save updated meta
  await saveMeta(meta);

  // 9. Return initialization state
  return {
    agentDir: AGENT_DIR,
    goalExists: true,
    goalUpdated,
    meta
  };
}
